Week01 Extra ltl
until operator

  Ï† until Ïˆ

  Ï† ğ’° Ïˆ   "Ï† holds for 0 or more states; immediately thereafter, Ïˆ holds"

eventually operator

  eventually Ï†  "after 0 or more states, Ï† holds"
  â—‡Ï†  "eventually Ï†"

  â—‡Ï†  â‰¡ âŠ¤ ğ’° Ï†   one possible definition in terms of existing operators

  â—‡Ï†  â‰¡ Â¬Ï† ğ’° Ï†   "Ï† is false for 0 or more states; then, it's true"

  Ïƒ âŠ§ â—‡Ï†     iff there exists i âˆˆ â„• s.t. Ïƒ|i âŠ§ Ï†
always operator

  always Ï† "from every future state, Ï† holds"
  â–¡Ï†  "always Ï†"

  â–¡Ï† â‰¡ Â¬(â—‡Â¬Ï†)           "Ï† is never false"

  Ïƒ âŠ§ â–¡Ï†   iff for all i âˆˆ â„•, Ïƒ|i âŠ§ Ï†

Let's prove this equation: â–¡Ï† â‰¡ Â¬(â—‡Â¬Ï†)
  using the semantic definitions we introduced above

To prove that two temporal logic formulas Ï† and Ïˆ are equivalent,
  we must prove that for behaviours Ïƒ,
   Ïƒ âŠ§ Ï†  iff Ïƒ âŠ§ Ïˆ

Ïƒ âŠ§ Â¬(â—‡Â¬Ï†)

iff (by definition)

Â¬ (Ïƒ âŠ§ â—‡Â¬Ï†)

iff (by definition)

Â¬ (âˆƒi. Ïƒ|i âŠ§ Â¬Ï†)

iff (by definition)

Â¬ (âˆƒi. Â¬(Ïƒ|i âŠ§ Ï†))

iff (logical law: Â¬ âˆƒx. P â‰¡ âˆ€x. Â¬ P)

âˆ€i. Â¬Â¬(Ïƒ|i âŠ§ Ï†)

iff (double negation)

âˆ€i. Ïƒ|i âŠ§ Ï†

iff (by definition (backwards))

Ïƒ âŠ§ â–¡Ï†

QED

We're using one logic (predicate logic, with âˆ€, âˆƒ and so on),
to reason about another logic (temporal logic, with â—‡, â–¡, â—¯, and so on)

Two layers: metalogic (predicate logic)
  object logic (temporal logic)


â–¡(Ï† âˆ§ Ïˆ) â‰¡ â–¡Ï† âˆ§ â–¡Ïˆ

Proof:

  Ïƒ âŠ§ â–¡(Ï† âˆ§ Î¨)
iff (by def)
  âˆ€i. Ïƒ|i âŠ§ Ï† âˆ§ Ïˆ      <-- this is the temporal logic conjunction (object logic)
iff (by def)
  âˆ€i. (Ïƒ|i âŠ§ Ï†) âˆ§ (Ïƒ|i âŠ§ Ïˆ)  <-- this is the predicate logic conjunction (metalogic)
iff (âˆ€ distributes over conjunction)
  (âˆ€i. Ïƒ|i âŠ§ Ï†) âˆ§ (âˆ€i. Ïƒ|i âŠ§ Ïˆ)
iff (by def (backwards (twice)))
  Ïƒ âŠ§ â–¡Ï†  âˆ§  Ïƒ âŠ§ â–¡ Î¨
iff (by def (backwards))
  Ïƒ âŠ§ â–¡Ï† âˆ§ â–¡Ïˆ
QED


Encode "infinitely often"

  "infinitely often" â‰ˆ "always eventually"
    no matter how far into the future we look, the thing is going to happen once more.

  Ï† is true infinitely often:
   â–¡â—‡Ï†

  "almost globally" (always true from some point onwards) â‰ˆ (eventually, we reach a point whence it's always true)

   â—‡â–¡Ï†

Expressiveness limits of LTL:
- Can't this be used to say "we can always reach the terminated state"?

  â–¡â—‡running

  Why doesn't that work?
  Suppose we remove the terminated state from our original transition system.
  Then, the above formula still holds.

Limitation: we can't express branching-time properties.

Can we use LTL to express all linear-time properties then?
A: No.
- The set of all behaviours is uncountable (i.e. there's no way to assign a natural number to every behaviour)
- (If the atomic props are countable),
   then there are only countably many LTL formulas.

Let's suppose the set of states is

  Î£ = {(, ), -}

Property: the behaviour is a sequence of balanced parentheses followed by infinitely many -:s

We can't write this in LTL!