Concurrent programs
- partial orders of events
  (event: e.g. a line of code, machine instruction, ...
          something we can execute atomically)
- an interleaving: lining up the events in a row
  in a manner that's consistent with the partial order
   "some scheduling of the events that might happen when we run the program"

States (Î£ the set of all states)

An interleaving gives rise to a *behaviour*

Behaviour is an infinite sequence of states
  Î£^Ï‰  the set of all behaviours

  The initial state,
  the state after the first event,
  the state after the second event,      
  ....

A *property* is a set of behaviours.
 Intuitively: a property is what you want to happen
 when you run a concurrent program.

We say that a program P satisfies a property A if

  âŸ¦PâŸ§ âŠ† A

  âŸ¦PâŸ§ denotes the semantics of P
   aka all possible behaviours of P


Uncountable implies that it's infinite

Uncountable means there's no bijection between the set of properties
  and the set of natural numbers

Suppose you tried to enumerate the behaviour:
 you tried  to assign a natural number to every behaviour.



Ïƒ = â™¥ â™  â™¥ â™  â™¥ â™  â™¥ â™¥ â™¥ â™¥ ...

Ïƒ|3 = â™¥ â™  â™¥


(Ïƒ is a variable pronounced sigma
 Ïƒ' is also a variable pronounced sigma-prime)


cl(A)   for limit closure of A

Our set of states Î£ is â„• (the natural numbers)

A = { 0 0 0 0 ...,
      0 1 1 1 ...,
      0 1 2 2 ...,
      0 1 2 3 3 3 3 ...,
      .... }

A is the set of all sequences of natural numbers that
- start at zero

- increment one number per state, until they reach some ceiling and
  stay there forever

What is the cl(A)?
- The set of all behaviours that, if we observe them for a finite amount of time,
  look indistinguishable from a behaviour in A.

One behaviour in cl(A) is:
  0 0 0 0 0 0 0 ....

  (as an aside: A âŠ† cl(A))

cl(A) = A âˆª {"all the natural numbers enumerated in order"}

cl(âˆ…) = âˆ…

If A is not dense,
  what's bigger? Î£^Ï‰ or A?
A: Î£^Ï‰ is *always* bigger. By definition, it's the set of all behaviours.


Take as definitions:
 (1) A safety property is (by def) a limit-closed set
 (1) A liveness property is (by def) a dense set

 B^C "the set of everything in Î£^Ï‰ except B"

 A - B   =  A âˆ© B^C (1)

 Î£^Ï‰ âˆ© B = B

 De Morgan:
  (A âˆ© B)^C   =   A^C âˆª B^C

 cl(P) âˆ©  Î£^Ï‰ - (cl(P) - P)     
 = (1)
 cl(P) âˆ©  Î£^Ï‰ âˆ© (cl(P) - P)^C
 = (1)
 cl(P) âˆ©  Î£^Ï‰ âˆ© (cl(P) âˆ© P^C)^C
 = (De Morgan)
 cl(P) âˆ©  Î£^Ï‰ âˆ© (cl(P)^C  âˆª P^C^C)
 = (double complement)
 cl(P) âˆ©  Î£^Ï‰ âˆ© (cl(P)^C  âˆª P)
 = (identity)
 cl(P) âˆ©  (cl(P)^C  âˆª P)
 = (distributivity)
 (cl(P) âˆ© cl(P)^C)  âˆª  (cl(P) âˆ© P)
 = (complementation)
 âˆ…  âˆª  (cl(P) âˆ© P)
 = (identity)
 cl(P) âˆ© P
 = (because P âŠ† cl(P))
 P


safety: s2 will not exist before s1 liveness: s1 will eventually
transition to s2?

safety: memory does not go over 100MB liveness: memory will allocate at least than 100MB


safety: the program never returns -1 after seeing an invalid input
liveness: after seeing an invalid input, the program eventually returns something


 âŠ§  "models"  "entails"

 V âŠ§ Ï†
 "the valuation V models the formula Ï†"

 In a world where the set of true atomic propositions is V,
 the formula Ï† is true.

 {x,z,Ã¥} âŠ§ x âˆ§ y        <-- is that a valid judgement? No, because y doesn't hold
                            in our world

 {x,y} âŠ§ x âˆ§ y   <-- that's a valid judgement


 â—¯Ï†   "in the next state, Ï† holds"

 Ï† ð’° Ïˆ   "Ï† will hold for a finite amount of states; then, Ïˆ will hold after that"
"phi until psi"

In the initial state, is this true?

 â—¯(â—¯â™¥) "in the next next state,
        hearts is true"


In propositional logic, the worlds (aka models)
  were just sets of propositional atoms.

In LTL, the worlds are behaviours.

(Until this point, Ïƒ|n to denote the finite prefix
 of Ïƒ of length n.)

Now, Ïƒ|n to denote the *suffix* of Ïƒ that you obtain
  by dropping the first n states.

If my behaviour Ïƒ is the sequence of â„•s.

  Ïƒ|2   =  2 3 4 5 6 7 ...


 We can define â—‡P  "eventually, P"

 as

   â—‡P = âŠ¤ ð’° P

   â–¡P "in every future state, P holds"

   â–¡P = Â¬(â—‡(Â¬P))